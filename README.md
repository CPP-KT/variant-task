# variant

Интерфейс и все свойства и гарантии должны соответствовать [std::variant](https://en.cppreference.com/w/cpp/utility/variant)

Обратите внимание на то, описание на cppreference для converting конструктора/operator=, которое прямо говорит, как их реализовывать. Такой код должен работать ожидаемым образом:
```
variant<string, bool> x = "abc";             // holds string
```
Но проблема в том, что указатель `char const*` приводится как к `bool`, так и к `char const*`. Изначально для этого в стандарте сделали небольшой "костыль" в [P0608R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html), по сути обработав специально ситуацию с конвертацией к bool (см. статью). Это иногда ведёт себя [неожиданным образом](https://cplusplus.github.io/LWG/issue3228), но пример выше решает.

Потом конверсию к bool признали narrowing: [P1957R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1957r2.html), а такие конвертации запрещены в константных выражениях. В том же предложении убрали "костыль" для конструктора варианта: теперь то, что отсекалось им, должно отсекаться из-за narrowing conversion и он больше не нужен. 

Но так случилось, что в имплементациях стандартной библиотеки реализовали изменение variant, но ещё не заимплементили сам narrowing conversion в компиляторах. В результате реализовать без "костыля" правильное поведение сейчас не получится, поэтому предлагается осознать всё выше написанное и имплементировать поведение из [P0608R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html).
